searchState.loadedDescShard("dioxus_core", 0, "dioxus-core\nThe ScopeId of the main scope passed into [<code>VirtualDom::new</code>]…\nAn arbitrary value that implements PartialEq and is static\nAdd these m children to the target element\nAssign the element at the given path the target ElementId.\nAn attribute on a DOM node, such as <code>id=&quot;my-thing&quot;</code> or …\nAny of the built-in values that the Dioxus VirtualDom …\nBoolean\nThe type of the builder for this component. Used to create …\nAn instance of an error captured by a descendant component.\nA <code>Component</code> is a function that takes <code>Properties</code> and …\nA component node\nAny component that implements the <code>ComponentFn</code> trait can be …\nCreate a placeholder in the DOM that we will use later.\nCreate a node specifically for text with the given value\nThis template node is unknown, and needs to be created at …\nThe attribute in this position is actually determined …\nA node created at runtime\nAn <code>Element</code> is a possibly-none <code>VNode</code> created by calling …\nAn statically known element in the dom.\nAn Element’s unique identifier.\nContains the error value\nContains the error value\nA wrapper around some generic data that handles the event…\nA float\nCreate inline fragments using Component syntax.\nA list of VNodes.\nA trait for anything that has a dynamic list of attributes\nInsert a number of nodes after a given node.\nInsert a number of nodes before a given node.\nSigned integer\nA trait that allows various items to be converted into a …\nA marker trait for platform configs. We use this marker to …\nA listener, like “onclick”\nLoad and clone an existing node from a template with a …\nA <code>Mutation</code> represents a single instruction for the …\nA static list of mutations that can be applied to the DOM. …\nCreate a new Event Listener.\nA struct that ignores all mutations\nA “none” value, resulting in the removal of an …\nA helper function for an Ok result that can be either a …\nContains the success value\nContains the success value\nA placeholder\nEvery “Props” used for a component must implement the …\nPush the given root node onto our stack.\nThe ScopeId of the topmost scope in the tree. This will be …\nRemove a particular node from the DOM\nRemove an existing Event Listener.\nReplace an existing element in the template at the given …\nReplace the target element (given by its ID) with the …\nA type alias for a result that can be either a boxed error …\nA global runtime that is shared across all scopes that …\nA component’s unique identifier.\nA component’s rendered state.\nSet the value of a node’s attribute.\nSet the textcontent of a node.\nA helper trait for <code>Callback</code>s that allows functions to …\nThis attribute is entirely known at compile time, enabling\nA task’s unique identifier.\nA static layout of a UI tree that describes a set of …\nAn attribute of the TemplateNode, created at compile time\nA statically known node in a layout.\nThis template node is just a piece of static text\nA text node\nText attribute\nAn instance of a child component\nA reference to a template along with any context needed to …\nA reference to a template along with any context needed to …\nA placeholder node, used by suspense and fragments\nA text node\nA virtual node system that progresses user events and …\nSomething that can handle the mutations that are generated …\nCreate a new <code>AttributeValue</code> with a value that implements …\nAdd these m children to the target element\nAssign the element at the given path the target ElementId.\nThe paths of each dynamic attribute relative to the root …\nGet the single scope at the top of the VirtualDom tree …\nCreate a builder for this component.\nDrop the task immediately.\nPrevent this event from continuing to bubble up the tree …\nConsume context from the current scope\nConsume context from the current scope\nCreate a new Event Listener.\nCreate a placeholder in the DOM that we will use later.\nCreate a node specifically for text with the given value\nGet the current runtime\nGet the current scope id\nGet the currently running task\nGet a reference to the inner data from this event\nThe data associated with this event\nCheck if the default action of the event is enabled.\nDowncast the error type into a concrete error type\nThe dynamic attribute slots in the template\nTry to load the dynamic node at the given index\nThe dynamic nodes in the template\nLoad a dynamic root at the given index\nAny mutations required to patch the renderer to match the …\nCreate a template with no nodes that will be skipped over …\nThis utility function launches the builder method so that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new error from a type that only implements <code>Display</code>…\nGet the current render since the inception of this …\nGet the current render since the inception of this …\nGet the state for any scope given its ID\nCall a listener inside the VirtualDom with data from …\nHandle an event with the Virtual Dom. This method is …\nCheck if the current scope has a context\nGet the height of the current scope\nReturns the scope id of this <code>ScopeState</code>.\nGet the type id of the component.\nGet the type id of the component.\nRun a closure inside the dioxus runtime\nRun a closure inside of scope’s runtime\nBuild the virtualdom with a global context inserted into …\nInsert a number of nodes after a given node.\nInsert a number of nodes before a given node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this item and produce a DynamicNode\nCreate a component from the props.\nCreate a component from the props.\nIs this template worth caching at all, since it’s …\nCheck if the current scope is a descendant of the given …\nThe key given to the root of this template.\nCreate a new <code>AttributeValue</code> with the listener variant from …\nLoad and clone an existing node from a template saved …\nConvert any item that implements <code>IntoDynNode</code> into a …\nMap the event data to a new type\nManually mark a scope as requiring a re-render\nMake the old props equal to the new props. Return if the …\nGet the mounted id for a dynamic attribute index\nGet the mounted id for a dynamic node index\nGet the mounted id for a root node index\nGet the scope this node is mounted to if it’s mounted\nGet the <code>ScopeId</code> this node is mounted to if it’s mounted\nThe name of this component\nThe name of the attribute.\nThe namespace of the attribute.\nMark the current scope as dirty, causing it to re-render\nCreate a new event from the inner data\nCreate a new <code>VComponent</code> variant\nCreate a new VirtualDom with a component that does not …\nCreate a new captured error\nCreate a new VNode\nCreate a new VText\nCreate a new <code>Attribute</code> from a name, value, namespace, and …\nStart a new future on the same thread as the rest of the …\nCreate a new VirtualDom with the given properties for the …\nThe paths of each node relative to the root of the …\nCall this function with the current scope set to the given …\nGet the owner for the current scope.\nGet the parent of the current scope if it exists\nGet the parent task of the given task, if it exists\nPause the task.\nCheck if the task is paused.\nCreate a template with a single placeholder node\nPoll the task immediately.\nCreate a new virtualdom and build it immediately\nThe purpose of this module is to alleviate imports of many …\nPrevent the default action of the event.\nProcess all events in the queue until there are no more …\nCheck if the event propagates up the tree to parent …\nProvide context to the current scope\nProvide a context to the root scope\nPush an attribute onto the list of attributes\nPushes the future onto the poll queue to be polled after …\nPush the given root node onto our stack.\nConvert the component to a function that takes props and …\nPerforms a <em>full</em> rebuild of the virtual dom, returning …\nRebuild the virtualdom without handling any of the …\n<code>VirtualDom::rebuild</code> to a vector of mutations for testing …\nRemove an existing Event Listener.\nRemove a particular node from the DOM\nRender whatever the VirtualDom has ready as fast as …\n<code>Self::render_immediate</code> to a vector of mutations for …\nRender any dirty scopes immediately, but don’t poll any …\nReplace the target element (given by its ID) with the …\nReplace an existing element in the template at the given …\nResume the task.\nGet a handle to the currently active head node arena for …\nThe list of template nodes that make up the template\nGet the current runtime\nSchedule an update for the current component\nCreate a subscription that schedules a future render for …\nSchedule an update for any component given its <code>ScopeId</code>.\nSet the task as active or paused.\nSet the value of a node’s attribute.\nSet the text content of a node.\nGet a VNode representation of the error if the error …\nSpawn the value into the dioxus runtime if it is an async …\nStart a new future on the same thread as the rest of the …\nSpawns the future but does not return the <code>Task</code>\nStart a new future on the same thread as the rest of the …\nPrevent this event from continuing to bubble up the tree …\nCheck if there are any suspended tasks remaining\nThe static nodes and static descriptor of the template\nThrow a <code>CapturedError</code> into a scope. The error will bubble …\nTry to get a handle to the currently active head node …\nStore a value between renders. The foundational hook for …\nThe actual text itself\nThe value of the attribute\nAn indication of we should always try and set the …\nRender the virtual dom, waiting for all suspense to be …\nWait for the scheduler to have any work that should be run …\nWait for the scheduler to have any work.\nWake the task.\nMark the error as being thrown from a specific scope\nBuild the virtualdom with a global context inserted into …\nWrap a closure so that it always runs in the runtime that …\nThe ID of the element being mounted to\nThe ID we’re assigning to this element/placeholder.\nThe ID we’re assigning to this element/placeholder.\nThe ID we’re assigning to this specific text nodes\nThe ID we’re assigning to this element being loaded from …\nThe ID of the node we’re going to replace with\nThe ID of the node to insert after.\nThe ID of the node to insert before.\nThe ID of the node to set the attribute of.\nThe ID of the node to set the textcontent of.\nThe ID of the node to attach the listener to.\nThe ID of the node to remove.\nThe ID of the node to remove.\nThe ID of the root node to push.\nWhich root are we loading from the template?\nThe number of nodes on the stack to append to the target …\nThe number of nodes on the stack to replace the target …\nThe number of nodes on the stack to replace the target …\nThe number of nodes on the stack to insert after the …\nThe number of nodes on the stack to insert before the …\nThe name of the attribute to set.\nThe name of the event to listen for.\nThe name of the event to remove.\nThe (optional) namespace of the attribute. For instance, …\nThe path of the child of the topmost node on the stack\nThe path of the child of the topmost node on the stack\nThe text content of this text node\nThe value of the attribute.\nThe textcontent of the node\nThe index\nThe name of this attribute.\nThe namespace of this attribute. Does not exist in the …\nThe value of this attribute, known at compile time\nA list of possibly dynamic attributes for this element\nA list of template nodes that define another set of …\nThe index of the dynamic node in the VNode’s …\nThe namespace of the element\nThe name of the element\nThe actual text\nThe render function returned early\nAn attribute on a DOM node, such as <code>id=&quot;my-thing&quot;</code> or …\nThe type of the builder for this component. Used to create …\nThe callback type generated by the <code>rsx!</code> macro when an <code>on</code> …\nA <code>Component</code> is a function that takes <code>Properties</code> and …\nAny component that implements the <code>ComponentFn</code> trait can be …\nProvides context methods to <code>Result</code> and <code>Option</code> types that …\nThis template node is unknown, and needs to be created at …\nThe attribute in this position is actually determined …\nAn <code>Element</code> is a possibly-none <code>VNode</code> created by calling …\nAn statically known element in the dom.\nContains the error value\nCreate a new error boundary component that catches any …\nA context with information about suspended components\nA wrapper around some generic data that handles the event…\nThe callback type generated by the <code>rsx!</code> macro when an <code>on</code> …\nCreate inline fragments using Component syntax.\nA trait for anything that has a dynamic list of attributes\nA value that can be converted into an attribute value\nA trait that allows various items to be converted into a …\nContains the success value\nEvery “Props” used for a component must implement the …\nReactivity\nAn error that can occur while rendering a component\nA global runtime that is shared across all scopes that …\nA guard for a new runtime. This must be used to override …\nA component’s unique identifier.\nA component’s rendered state.\nThis attribute is entirely known at compile time, enabling\nA enhanced version of the <code>From</code> trait that allows with more …\nA enhanced version of the <code>Into</code> trait that allows with more …\nThe component was suspended\nA task that has been suspended which may have an optional …\nSuspense Boundaries let you render a fallback UI while a …\nProperties for the <code>SuspenseBoundary()</code> component.\nA context with information about suspended components\nProvides context methods to <code>Result&lt;T, RenderError&gt;</code> to show …\nA task’s unique identifier.\nA static layout of a UI tree that describes a set of …\nAn attribute of the TemplateNode, created at compile time\nA statically known node in a layout.\nThis template node is just a piece of static text\nA reference to a template along with any context needed to …\nA reference to a template along with any context needed to …\nA virtual node system that progresses user events and …\nThe paths of each dynamic attribute relative to the root …\nCreate a builder for this component.\nCall this callback with the appropriate argument type\nClear all errors from this Error Boundary\nClear all subscribers to this context\nConsume context from the current scope\nConsume context from the current scope\nWrap the result additional context about the error that …\nGet the current reactive context from the nearest reactive …\nReturns the current owner. This owner will be used to drop …\nGet the current scope id\nThe data associated with this event\nTry to get a suspense boundary from a scope id\nThe dynamic attribute slots in the template\nThe dynamic nodes in the template\nGet all errors thrown from child components\nThis utility function launches the builder method so that …\nResolve the suspense boundary on the server and freeze it …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if the suspense boundary is resolved and frozen\nGet the current render since the inception of this …\nCheck if the current scope has a context\nCheck if there are any suspended tasks\nGet the type id of the component.\nRun a closure under a suspense placeholder\nPush an error into this Error Boundary\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>impl FnMut + Copy</code> closure from the Closure type\nConsume this item and produce a DynamicNode\nConvert into an attribute value\nCreate a component from the props.\nCheck if the suspense boundary is currently rendered as …\nThe key given to the root of this template.\nLeak a new <code>Callback</code> that will not be dropped unless it is …\nMarks this reactive context as dirty\nMake the old props equal to the new props. Return if the …\nThe name of the attribute.\nThe namespace of the attribute.\nMark the current scope as dirty, causing it to re-render\nMark the current scope as dirty, causing it to re-render\nCreate a new <code>Callback</code> from an <code>FnMut</code>. The callback is owned …\nCreate a new runtime guard that sets the current Dioxus …\nCreate a new reactive context\nCreate a new suspended future\nCreate a new reactive context that may update a scope. …\nCreate a new reactive context with a location for …\nThe paths of each node relative to the root of the …\nGet the scope that inner CopyValue is associated with\nGet the parent of the current scope if it exists\nProvide context to the current scope\nProvide an error boundary to catch errors from child …\nProvide a context to the root scope\nPush an attribute onto the list of attributes\nQueue an effect to run after the next render. You …\nConvert the component to a function that takes props and …\nForcibly drop the internal handler callback, releasing …\nInforms the scheduler that this task is no longer needed …\nReplace the function in the callback with a new one\nReset the reactive context and then run the callback in …\nThe list of template nodes that make up the template\nRun this function in the context of this reactive context\nSchedule an update for the current component\nSchedule an update for any component given its <code>ScopeId</code>.\nAdd a visual representation of the error that the …\nGet the Element from the first error that can be shown\nSpawns the future but does not return the <code>Task</code>. This task …\nSpawn a future that Dioxus won’t clean up when this …\nStart a new future on the same thread as the rest of the …\nSubscribe to this context. The reactive context will …\nConvert from a type to another type.\nConvert from a type to another type.\nSuspended the current component on a specific task and …\nGet all suspended tasks\nGet the suspense boundary’s suspended nodes\nGet a placeholder to display while the future is suspended\nGet the first suspended task with a loading placeholder\nGet the task that was suspended\nThe static nodes and static descriptor of the template\nThrow a <code>CapturedError</code> into the current scope. The error …\nConsume context from the current scope\nRun a closure under a suspense boundary\nPush this function to be run after the next render\nA hook that allows you to insert a “before render” …\nCreates a callback that will be run before the component …\nStore a value between renders. The foundational hook for …\nUse a hook with a cleanup function\nThe value of the attribute\nAn indication of we should always try and set the …\nWrap the result with additional context about the error …\nAdd a loading indicator if the result is suspended\nRun a closure with the given owner.\nSet a new placeholder the SuspenseBoundary may use to …\nThe index\nThe name of this attribute.\nThe namespace of this attribute. Does not exist in the …\nThe value of this attribute, known at compile time\nA list of possibly dynamic attributes for this element\nA list of template nodes that define another set of …\nThe index of the dynamic node in the VNode’s …\nThe namespace of the element\nThe name of the element\nThe actual text")