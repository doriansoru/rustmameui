searchState.loadedDescShard("dioxus_hooks", 0, "Dioxus Hooks\nA dependency is a trait that can be used to determine if a …\nA dependency is a trait that can be used to determine if a …\nA handle to an effect.\nThe output of the dependency\nThe future has been paused, tempoarily\nThe resource’s future has been paused, tempoarily\nThe future is still running\nThe resource’s future is still running\nThe future has completed\nThe resource’s future has completed\nA handle to a reactive future spawned with <code>use_resource</code> …\nThe future has been forcefully stopped\nThe resource’s future has been forcefully stopped\nThe receiving end of an unbounded mpsc channel.\nThe transmission end of an unbounded mpsc channel.\nA signal that represents the state of a future\nA signal that represents the state of the resource\nForcefully cancel a future\nForcefully cancel the resource’s future.\nReturns true if the dependency has changed.\nReturns true if the dependency has changed.\nClear the resource’s value. This will just reset the …\nCloses the receiving half of a channel, without dropping …\nCloses this channel from the sender side, preventing any …\nDisconnects this sender from the channel, closing it if …\nIs the future currently finished running?\nIs the resource’s future currently finished running?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHashes the receiver into the provided hasher\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this channel is closed without needing a …\nReturns whether the sender send to this receiver.\nReturn false is channel has no queued messages, true …\nReturn the number of messages in the queue or 0 if channel …\nMarks the effect as dirty, causing it to rerun on the next …\nReturns the output of the dependency.\nPause the future\nPause the resource’s future.\nCheck if the channel is ready to receive a message.\nRestart this coroutine\nRestart the future with new dependencies.\nRestart the resource’s future.\nResume the future\nResume the resource’s future.\nReturns whether the senders send to the same receiver.\nSend a message to the coroutine\nSend a message on the channel.\nGet the current state of the future.\nGet the current state of the resource’s future. This …\nSuspend the resource’s future and only continue …\nGet the underlying task handle\nGet a handle to the inner task backing this future Modify …\nGet a handle to the inner task backing this resource …\nA helper macro for cloning multiple values at once\nTries to receive the next message without notifying a …\nConsume some context in the tree, providing a sharable …\nSends a message along this channel.\nCreate a callback that’s always up to date. Whenever …\nConsume some context in the tree, providing a sharable …\nProvide some context via the tree and return a reference …\nMaintain a handle over a future that can be paused, …\nGet a handle to a coroutine higher in the tree Analogous …\nEffects are reactive closures that run <strong>after the component </strong>…\nA hook that allows you to spawn a future the first time …\nA hook that uses before/after lifecycle hooks to determine …\nCreates a new Memo. The memo will be run immediately and …\nTakes some non-reactive data, and a closure and returns a …\nA helper macro for <code>use_reactive</code> that merges uses the …\nA helper macro for <code>use_reactive</code> that merges uses the …\n<code>use_resource()</code> is a reactive hook that resolves to the …\nTry to get a value from the root of the virtual dom, if it …\nCreates a new SetCompare which efficiently tracks when a …\nA hook that returns true if the value is equal to the …\nCreates a new Signal. Signals are a Copy state management …\nCreates a new `Send + Sync`` Signal. Signals are a Copy …\nGet the current value of the resource’s future.  This …")