searchState.loadedDescShard("dioxus_rsx", 0, "Parse the root tokens in the rsx! { } macro\nattribute: some_expr attribute: {some_expr} ?\nAny attribute that’s a literal. These get hotreloading …\nA property value in the from of a <code>name: value</code> pair with an …\nA bool literal\nan attribute in the form of <code>name: value</code>\nThe Callbody is the contents of the rsx! macro\nComponent {}\nan attribute in the form of <code>&quot;name&quot;: value</code> - notice that …\nA collection of diagnostics\nA collection of diagnostics\nA simple idx in the code that can be used to track back to …\nParse the VNode::Element type\ndiv {}\nA series of tokens that represent an event handler\nA float literal\nA <em>formatted</em> string literal We know this will generate a …\nfor item in items {}\nA literal value in the rsx! macro\nA formatted segment that can be hot reloaded\nA if else chain attribute value\nif cond {} else if cond {} (else {}?)\nConditional expression\nA hot-reloadable formatted string, boolean, number or …\nAn int literal\nA closure whose body might not be valid rust code but we …\nA raw expression potentially wrapped in curly braces that …\n{expr}\nAn item in the form of\nJust a regular shorthand attribute - an ident. Makes our …\nA set of nodes in a template position\nA set of nodes in a template position\n“text {formatted}”\nConvert this partial closure into a full closure if it is …\nthe brace of the <code>div { }</code>\nThe children of the element\nThe colon that separates the name and value - keep this …\nThe comma that separates this attribute from the next one …\nA list of diagnostics that were generated during parsing. …\nThe dynamic index of this attribute - used by the template …\nThe element name of this attribute if it is bound to an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new attribute from a name and value\nGet the dynamic index of this attribute\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate through the literal component properties of this …\nThe attributes after merging - basically the formatted …\nThe name of the attribute (ident or custom)\ndiv { } -&gt; div\nCreate a new CallBody from a TemplateBody\nCreate a new TemplateBody from a set of nodes\nNormalize the Template body for rendering. If the body is …\nParse the nodes of the callbody as <code>Body</code>.\nOnly parse the children of the block - all others will be …\nParse a raw ident and return a new ident with the r# …\nParse a stream into a CallBody. Return all error …\nThe actual attributes that were parsed\nSet the dynamic index of this attribute\nThis method is very important! Deref + Spanned + .span() …\nThe <code>...</code> spread attributes.\nprint the original source string - this handles escapes …\nThe value of the attribute\nRun this closure against the attribute if it’s …")