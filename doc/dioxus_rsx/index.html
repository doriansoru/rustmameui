<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parse the root tokens in the rsx! { } macro"><title>dioxus_rsx - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="dioxus_rsx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://avatars.githubusercontent.com/u/79236386"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../dioxus_rsx/index.html"><img src="https://avatars.githubusercontent.com/u/79236386" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../dioxus_rsx/index.html"><img src="https://avatars.githubusercontent.com/u/79236386" alt="logo"></a><h2><a href="../dioxus_rsx/index.html">dioxus_<wbr>rsx</a><span class="version">0.6.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#parse-the-root-tokens-in-the-rsx---macro" title="Parse the root tokens in the rsx! { } macro">Parse the root tokens in the rsx! { } macro</a></li><li><a href="#completions" title="Completions">Completions</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>dioxus_rsx</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/dioxus_rsx/lib.rs.html#1-106">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="parse-the-root-tokens-in-the-rsx---macro"><a class="doc-anchor" href="#parse-the-root-tokens-in-the-rsx---macro">§</a>Parse the root tokens in the rsx! { } macro</h2>
<p>This parsing path emerges directly from the macro call, with <code>RsxRender</code> being the primary entrance into parsing.
This feature must support:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Optionally rendering if the <code>in XYZ</code> pattern is present</li>
<li><input disabled="" type="checkbox" checked=""/>
Fragments as top-level element (through ambiguous)</li>
<li><input disabled="" type="checkbox" checked=""/>
Components as top-level element (through ambiguous)</li>
<li><input disabled="" type="checkbox" checked=""/>
Tags as top-level elements (through ambiguous)</li>
<li><input disabled="" type="checkbox" checked=""/>
Good errors if parsing fails</li>
</ul>
<p>Any errors in using rsx! will likely occur when people start using it, so the first errors must be really helpful.</p>
<h2 id="completions"><a class="doc-anchor" href="#completions">§</a>Completions</h2>
<p>Rust analyzer completes macros by looking at the expansion of the macro and trying to match the start of identifiers in the macro to identifiers in the current scope</p>
<p>Eg, if a macro expands to this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>MyStruct;

<span class="comment">// macro expansion
</span>My</code></pre></div>
<p>Then the analyzer will try to match the start of the identifier “My” to an identifier in the current scope (MyStruct in this case).</p>
<p>In dioxus, our macros expand to the completions module if we know the identifier is incomplete:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// In the root of the macro, identifiers must be elements
// rsx! { di }
</span>dioxus_elements::elements::di

<span class="comment">// Before the first child element, every following identifier is either an attribute or an element
// rsx! { div { ta } }
// Isolate completions scope
</span><span class="kw">mod </span>completions__ {
    <span class="comment">// import both the attributes and elements this could complete to
    </span><span class="kw">use </span>dioxus_elements::elements::div::<span class="kw-2">*</span>;
    <span class="kw">use </span>dioxus_elements::elements::<span class="kw-2">*</span>;
    <span class="kw">fn </span>complete() {
        ta;
    }
}

<span class="comment">// After the first child element, every following identifier is another element
// rsx! { div { attribute: value, child {} di } }
</span>dioxus_elements::elements::di</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Attribute.html" title="struct dioxus_rsx::Attribute">Attribute</a></dt><dd>A property value in the from of a <code>name: value</code> pair with an optional comma.
Note that the colon and value are optional in the case of shorthand attributes. We keep them around
to support “lossless” parsing in case that ever might be useful.</dd><dt><a class="struct" href="struct.CallBody.html" title="struct dioxus_rsx::CallBody">Call<wbr>Body</a></dt><dd>The Callbody is the contents of the rsx! macro</dd><dt><a class="struct" href="struct.Component.html" title="struct dioxus_rsx::Component">Component</a></dt><dt><a class="struct" href="struct.Diagnostics.html" title="struct dioxus_rsx::Diagnostics">Diagnostics</a></dt><dd>A collection of diagnostics</dd><dt><a class="struct" href="struct.DynIdx.html" title="struct dioxus_rsx::DynIdx">DynIdx</a></dt><dd>A simple idx in the code that can be used to track back to the original source location</dd><dt><a class="struct" href="struct.Element.html" title="struct dioxus_rsx::Element">Element</a></dt><dd>Parse the VNode::Element type</dd><dt><a class="struct" href="struct.ExprNode.html" title="struct dioxus_rsx::ExprNode">Expr<wbr>Node</a></dt><dt><a class="struct" href="struct.ForLoop.html" title="struct dioxus_rsx::ForLoop">ForLoop</a></dt><dt><a class="struct" href="struct.FormattedSegment.html" title="struct dioxus_rsx::FormattedSegment">Formatted<wbr>Segment</a></dt><dt><a class="struct" href="struct.HotReloadFormattedSegment.html" title="struct dioxus_rsx::HotReloadFormattedSegment">HotReload<wbr>Formatted<wbr>Segment</a></dt><dd>A formatted segment that can be hot reloaded</dd><dt><a class="struct" href="struct.IfAttributeValue.html" title="struct dioxus_rsx::IfAttributeValue">IfAttribute<wbr>Value</a></dt><dd>A if else chain attribute value</dd><dt><a class="struct" href="struct.IfChain.html" title="struct dioxus_rsx::IfChain">IfChain</a></dt><dt><a class="struct" href="struct.IfmtInput.html" title="struct dioxus_rsx::IfmtInput">Ifmt<wbr>Input</a></dt><dd>A hot-reloadable formatted string, boolean, number or other literal</dd><dt><a class="struct" href="struct.PartialClosure.html" title="struct dioxus_rsx::PartialClosure">Partial<wbr>Closure</a></dt><dd>A closure whose body might not be valid rust code but we want to interpret it regardless.
This lets us provide expansions in way more cases than normal closures at the expense of an
increased mainteance burden and complexity.</dd><dt><a class="struct" href="struct.PartialExpr.html" title="struct dioxus_rsx::PartialExpr">Partial<wbr>Expr</a></dt><dd>A raw expression potentially wrapped in curly braces that is parsed from the input stream.</dd><dt><a class="struct" href="struct.RsxBlock.html" title="struct dioxus_rsx::RsxBlock">RsxBlock</a></dt><dd>An item in the form of</dd><dt><a class="struct" href="struct.Spread.html" title="struct dioxus_rsx::Spread">Spread</a></dt><dt><a class="struct" href="struct.TemplateBody.html" title="struct dioxus_rsx::TemplateBody">Template<wbr>Body</a></dt><dd>A set of nodes in a template position</dd><dt><a class="struct" href="struct.TextNode.html" title="struct dioxus_rsx::TextNode">Text<wbr>Node</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AttributeName.html" title="enum dioxus_rsx::AttributeName">Attribute<wbr>Name</a></dt><dt><a class="enum" href="enum.AttributeValue.html" title="enum dioxus_rsx::AttributeValue">Attribute<wbr>Value</a></dt><dt><a class="enum" href="enum.BodyNode.html" title="enum dioxus_rsx::BodyNode">Body<wbr>Node</a></dt><dt><a class="enum" href="enum.ElementName.html" title="enum dioxus_rsx::ElementName">Element<wbr>Name</a></dt><dt><a class="enum" href="enum.FormattedSegmentType.html" title="enum dioxus_rsx::FormattedSegmentType">Formatted<wbr>Segment<wbr>Type</a></dt><dt><a class="enum" href="enum.HotLiteral.html" title="enum dioxus_rsx::HotLiteral">HotLiteral</a></dt><dd>A literal value in the rsx! macro</dd><dt><a class="enum" href="enum.RsxItem.html" title="enum dioxus_rsx::RsxItem">RsxItem</a></dt><dt><a class="enum" href="enum.Segment.html" title="enum dioxus_rsx::Segment">Segment</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.parse_raw_ident.html" title="fn dioxus_rsx::parse_raw_ident">parse_<wbr>raw_<wbr>ident</a></dt><dd>Parse a raw ident and return a new ident with the r# prefix added</dd></dl></section></div></main></body></html>