<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A rust serialization library that works in const with complex(ish) types like enums, nested structs and arrays. Const rust does not have an allocator, so this library cannot work in a cross architecture environment with Vecs, slices or strings."><title>const_serialize - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="const_serialize" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../const_serialize/index.html">const_<wbr>serialize</a><span class="version">0.6.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#how-it-works" title="How it works">How it works</a></li><li><a href="#limitations" title="Limitations">Limitations</a></li></ul><h3><a href="#macros">Crate Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>const_serialize</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/const_serialize/lib.rs.html#1-937">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A rust serialization library that works in const with complex(ish) types like enums, nested structs and arrays. Const rust does not have an allocator, so this library cannot work in a cross architecture environment with Vecs, slices or strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>const_serialize::{deserialize_const, serialize_const, serialize_eq, ConstVec, SerializeConst};
<span class="attr">#[derive(Clone, Copy, Debug, PartialEq, SerializeConst)]
</span><span class="kw">struct </span>Struct {
    a: u32,
    b: u8,
    c: u32,
    d: Enum,
}

<span class="attr">#[derive(Clone, Copy, Debug, PartialEq, SerializeConst)]
#[repr(C, u8)]
</span><span class="kw">enum </span>Enum {
    A { one: u32, two: u16 },
    B { one: u8, two: u16 } = <span class="number">15</span>,
}

<span class="kw">const </span>{
    <span class="kw">let </span>data = [Struct {
        a: <span class="number">0x11111111</span>,
        b: <span class="number">0x22</span>,
        c: <span class="number">0x33333333</span>,
        d: Enum::A {
            one: <span class="number">0x44444444</span>,
            two: <span class="number">0x5555</span>,
        },
    }; <span class="number">3</span>];
    <span class="kw">let </span><span class="kw-2">mut </span>buf = ConstVec::new();
    buf = serialize_const(<span class="kw-2">&amp;</span>data, buf);
    <span class="kw">let </span>buf = buf.read();
    <span class="kw">let </span>(buf, deserialized) = <span class="kw">match </span><span class="macro">deserialize_const!</span>([Struct; <span class="number">3</span>], buf) {
        <span class="prelude-val">Some</span>(data) =&gt; data,
        <span class="prelude-val">None </span>=&gt; <span class="macro">panic!</span>(<span class="string">"data mismatch"</span>),
    };
    <span class="kw">if </span>!serialize_eq(<span class="kw-2">&amp;</span>data, <span class="kw-2">&amp;</span>deserialized) {
        <span class="macro">panic!</span>(<span class="string">"data mismatch"</span>);
    }
}</code></pre></div>
<h3 id="how-it-works"><a class="doc-anchor" href="#how-it-works">§</a>How it works</h3>
<p><code>const-serialize</code> relies heavily on well defined layouts for the types you want to serialize. The serialization format is the linear sequence of unaligned bytes stored in the order of the fields, items or variants of the type. Numbers are stored in little endian order.</p>
<p>In order to support complex nested types, serialization is done using a trait. Since functions in traits cannot be const, <code>const-serialize</code> uses a macro to generate constant associated items that describe the memory layout of the type. That layout is then used to read all of the bytes in the type into the serialized buffer.</p>
<p>The deserialization is done in a similar way, but the layout is used to write the bytes from the serialized buffer into the type.</p>
<p>The rust <a href="https://doc.rust-lang.org/nomicon/data.html">nomicon</a> defines the memory layout of different types. It is used as a reference for the layout of the types implemented in <code>const-serialize</code>.</p>
<h3 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h3>
<ul>
<li>Only constant sized types are supported. This means that you can’t serialize a type like <code>Vec&lt;T&gt;</code>. These types are difficult to create in const contexts in general</li>
<li>Only types with a well defined memory layout are supported (see https://github.com/rust-lang/rfcs/pull/3727 and https://onevariable.com/blog/pods-from-scratch). <code>repr(Rust)</code> enums don’t have a well defined layout, so they are not supported. <code>repr(C, u8)</code> enums can be used instead</li>
<li>Const rust does not support mutable references or points, so this crate leans heavily on function data structures for data processing.</li>
</ul>
</div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.deserialize_const.html" title="macro const_serialize::deserialize_const">deserialize_<wbr>const</a></dt><dd>Deserialize a type into the output buffer. Accepts (Type, ConstVec<u8>) as input and returns Option&lt;(ConstReadBuffer, Instance of type)&gt;</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ConstReadBuffer.html" title="struct const_serialize::ConstReadBuffer">Const<wbr>Read<wbr>Buffer</a></dt><dd>A buffer that can be read from at compile time. This is very similar to <a href="https://doc.rust-lang.org/1.86.0/std/io/cursor/struct.Cursor.html" title="struct std::io::cursor::Cursor">Cursor</a> but is
designed to be used in const contexts.</dd><dt><a class="struct" href="struct.ConstStr.html" title="struct const_serialize::ConstStr">Const<wbr>Str</a></dt><dd>A string that is stored in a constant sized buffer that can be serialized and deserialized at compile time</dd><dt><a class="struct" href="struct.ConstVec.html" title="struct const_serialize::ConstVec">Const<wbr>Vec</a></dt><dd><a href="struct.ConstVec.html" title="struct const_serialize::ConstVec"><code>ConstVec</code></a> is a version of <a href="https://doc.rust-lang.org/1.86.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a> that is usable in const contexts. It has
a fixed maximum size, but it can can grow and shrink within that size limit
as needed.</dd><dt><a class="struct" href="struct.EnumLayout.html" title="struct const_serialize::EnumLayout">Enum<wbr>Layout</a></dt><dd>The layout for an enum. The enum layout is just a discriminate size and a tag layout.</dd><dt><a class="struct" href="struct.EnumVariant.html" title="struct const_serialize::EnumVariant">Enum<wbr>Variant</a></dt><dd>The layout for an enum variant. The enum variant layout is just a struct layout with a tag and alignment.</dd><dt><a class="struct" href="struct.ListLayout.html" title="struct const_serialize::ListLayout">List<wbr>Layout</a></dt><dd>The layout for a constant sized array. The array layout is just a length and an item layout.</dd><dt><a class="struct" href="struct.PrimitiveLayout.html" title="struct const_serialize::PrimitiveLayout">Primitive<wbr>Layout</a></dt><dd>The layout for a primitive type. The bytes will be reversed if the target is big endian.</dd><dt><a class="struct" href="struct.StructFieldLayout.html" title="struct const_serialize::StructFieldLayout">Struct<wbr>Field<wbr>Layout</a></dt><dd>Plain old data for a field. Stores the offset of the field in the struct and the layout of the field.</dd><dt><a class="struct" href="struct.StructLayout.html" title="struct const_serialize::StructLayout">Struct<wbr>Layout</a></dt><dd>Layout for a struct. The struct layout is just a list of fields with offsets</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Layout.html" title="enum const_serialize::Layout">Layout</a></dt><dd>The layout for a type. This layout defines a sequence of locations and reversed or not bytes. These bytes will be copied from during serialization and copied into during deserialization.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.SerializeConst.html" title="trait const_serialize::SerializeConst">Serialize<wbr>Const</a></dt><dd>A trait for types that can be serialized and deserialized in const.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.deserialize_const_raw.html" title="fn const_serialize::deserialize_const_raw">deserialize_<wbr>const_<wbr>raw</a><sup title="unsafe function">⚠</sup></dt><dd>Deserialize a buffer into a type. This will return None if the buffer doesn’t have enough data to fill the type.</dd><dt><a class="fn" href="fn.serialize_const.html" title="fn const_serialize::serialize_const">serialize_<wbr>const</a></dt><dd>Serialize a type into a buffer</dd><dt><a class="fn" href="fn.serialize_eq.html" title="fn const_serialize::serialize_eq">serialize_<wbr>eq</a></dt><dd>Check if the serialized representation of two items are the same</dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.SerializeConst.html" title="derive const_serialize::SerializeConst">Serialize<wbr>Const</a></dt><dd>Derive the const serialize trait for a struct</dd></dl></section></div></main></body></html>